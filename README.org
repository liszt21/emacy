# ;-*- eval: (load-file "./init-dev.el");   -*-
#+TITLE: My Emacs Config
#+AUTHOR: Li Shuzhi
#+STARTUP: content
#+FILETAGS: :Emacy:Config:Emacs:EmacsLisp:
#+PROPERTY: emacs config emacy
#+PROPERTY: header-args :tangle init.el :noweb yes :session init

* Inbox
** TODO Refactor
* TODO [[https://depp.brause.cc/shackle/][shackle]]

* Header
#+BEGIN_SRC emacs-lisp :tangle early-init.el
;;; early-init.el --- emacs init file  -*- lexical-binding: t; -*-
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;; init.el --- emacs init file  -*- lexical-binding: t; -*-
(require 'cl-lib)
#+END_SRC

* Constant
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(defconst windows? (memq system-type '(cygwin windows-nt ms-dos)) "are we on windows")
(defconst macos? (eq system-type 'darwin) "are we on macos")
(defconst linux? (memq system-type '(gnu gnu/linux gnu/kfreebds berkeley-unix)) "are we on linux")
(defconst bsd? (memq system-type '(darwin berkeley-unix gnu/kfreebsd)) "are we on bsd")
(defconst wsl? (and linux? (string-match-p "microsoft" operating-system-release)) "are we on wsl")
#+END_SRC

* Variable
#+BEGIN_SRC emacs-lisp
(defvar elpaca-directory (expand-file-name "var/elpaca" (if wsl? user-local-directory user-emacs-directory)))
(defvar elpaca-builds-directory (expand-file-name "builds" elpaca-directory))
(defvar elpaca-cache-directory (expand-file-name "menus" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "libs" user-emacs-directory))
#+END_SRC

* Default
#+BEGIN_SRC emacs-lisp
(display-time-mode)
(toggle-frame-maximized)
(global-auto-revert-mode)
(global-display-line-numbers-mode)
(toggle-word-wrap)
(global-word-wrap-whitespace-mode 1)

(tab-bar-mode -1)

(setq custom-file (expand-file-name "var/custom.el" user-emacs-directory))
#+END_SRC

* Package Manager
** [[https://github.com/progfolio/elpaca][Elpaca]]
*** Introduce
#+BEGIN_SRC emacs-lisp
(defvar elpaca-installer-version 0.6)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (call-process "git" nil buffer t "clone"
                                       (plist-get order :repo) repo)))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+END_SRC

*** config
#+BEGIN_SRC emacs-lisp
(elpaca elpaca-use-package
  (elpaca-use-package-mode)
  (setq elpaca-use-package-by-default t
        use-package-compute-statistics t))

(when windows? (setq elpaca-queue-limit 21))

(defmacro use-feature (name &rest args)
  "Like `use-package' but accounting for asynchronous installation.
  NAME and ARGS are in `use-package'."
  (declare (indent defun))
  `(use-package ,name
     :elpaca nil
     :ensure nil
     ,@args))

(elpaca-wait)
#+END_SRC

* KeyBind
** which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :demand t
  :init
  (setq which-key-enable-extended-define-key t)
  :config
  (which-key-mode)
  :custom
  (which-key-side-window-location 'bottom)
  (which-key-sort-order 'which-key-key-order-alpha)
  (which-key-side-window-max-width 0.33)
  (which-key-idle-delay 0.12)
  :diminish which-key-mode)
#+END_SRC

** general
#+BEGIN_SRC emacs-lisp
(use-package general
  :demand t
  :config
  (general-override-mode)
  (general-auto-unbind-keys)
  (general-evil-setup)
  (general-define-key
   :states '(normal insert motion emacs)
   :keymaps 'override
   :prefix-map 'tyrant-map
   :prefix "SPC"
   :non-normal-prefix "M-SPC")
  
  (general-create-definer tyrant-def :keymaps 'tyrant-map)
  (tyrant-def "" nil)
  
  (general-create-definer despot-def
    :states '(normal insert motion emacs)
    :keymaps 'override
    :major-modes t
    :prefix "SPC m"
    :non-normal-prefix "M-SPC m")
  (despot-def "" nil)
  
  (general-def universal-argument-map "SPC u" 'universal-argument-more)
  (tyrant-def
      "SPC"     '("M-x" . execute-extended-command)
      "!"       '("shell cmd" . shell-command)
  
      "a"       (cons "applications" (make-sparse-keymap))
      "ac"      'calc-dispatch
      "ap"      'list-processes
      "aP"      'proced
  
      "ae"      (cons "elpaca" (make-sparse-keymap))
      "aeb" 'elpaca-browse
      "aer"  '((lambda () (interactive) (let ((current-prefix-arg (not current-prefix-arg))) (call-interactively #'elpaca-rebuild))) :which-key "rebuild")
      "aem" 'elpaca-manager
      "ael" 'elpaca-log
      "aei" 'elpaca-info
      "aeI" '((lambda () (interactive) (info "Elpaca")) :which-key "elpaca-info")
      "aes" 'elpaca-status
      "aet" 'elpaca-try
      "aev" 'elpaca-visit
  
      "b"       (cons "buffers" (make-sparse-keymap))
      "bb"      'switch-to-buffer
      "bc"      'consult-buffer
      "bi"      'ibuffer
      "bd"      'kill-current-buffer
      "bm"      'switch-to-messages-buffer
      "bs"      'scratch-buffer
      "bu"      'reopen-killed-buffer
      "bx"      'kill-buffer-and-window
      "b TAB"    '("last buffer" . alternate-buffer)
  
      "c"       (cons "code" (make-sparse-keymap))
      "cb"      'flymake-show-buffer-diagnostics
      "cc"      'compile
      "cd"      'lsp-bridge-find-def
      "cD"      'lsp-bridge-find-references
      "cn"      'next-error
      "cp"      'previous-error
      "cr"      'recompile
      "cx"      'kill-compilation
      "c="      'indent-region-or-buffer
  
      "f"       (cons "files" (make-sparse-keymap))
      "fC"      '("copy-file" . write-file)
      "fD"      'delete-current-buffer-file
      ;; "fe"      'find-library
      "fE"      'sudo-edit
      "ff"      'find-file
      "fj"      'dired-jump
      "fJ"      'dired-jump-other-window
      "fo"      'open-file-or-directory-in-external-app
      "fr"      'read-only-mode
      "fR"      'rename-current-buffer-file
      "fd"   '((lambda (&optional arg) (interactive "P") (let ((buffer (when arg (current-buffer)))) (diff-buffer-with-file buffer))) :which-key "diff-with-file")
  
      "fe"   (cons "emacs" (make-sparse-keymap))
      "fed"  '((lambda () (interactive) (find-file-existing literate-file) (widen)) :which-key "dotfile")
      "feR"  '((lambda () (interactive) (load-file user-init-file)) :which-key "reload-init.el")
      "fet"  '((lambda () (interactive)
                (save-restriction (widen) (check-parens) (org-babel-tangle-file literate-file))
                (load-file "~/Projects/Emacy/profiles/emacy/init.el"))
               :which-key "tangle/reload-init.el")
      "fl"   '((lambda (&optional arg) (interactive "P") (call-interactively (if arg #'find-library-other-window #'find-library))) :which-key "+find-library")
      "fp"   'find-function-at-point
      "fP"   'find-function
      "fR"   'rename-file-and-buffer
      "fs"   'save-buffer
      "fv"   'find-variable-at-point
      "fV"   'find-variable
      ;; "fv"      (cons "variables" (make-sparse-keymap))
      ;; "fvd"     'add-dir-local-variable
      ;; "fvf"     'add-file-local-variable
      ;; "fvp"     'add-file-local-variable-prop-line
  
      "F"       (cons "frame" (make-sparse-keymap))
      "Fd"      'delete-frame
      "FD"      'delete-other-frames
      "Fn"      'make-frame
      "Fo"      'other-frame
      "FD" 'delete-other-frames
      "FF" 'select-frame-by-name
      "FO" 'other-frame-prefix
      "Fc" '(:ingore t :which-key "color")
      "Fcb" 'set-background-color
      "Fcc" 'set-cursor-color
      "Fcf" 'set-foreground-color
      "Ff" 'set-frame-font
      "Fm" 'make-frame-on-monitor
      "Fn" 'next-window-any-frame
      "Fo" 'other-frame
      "Fp" 'previous-window-any-frame
      "Fr" 'set-frame-name
  
      "h"       (cons "help" (make-sparse-keymap))
      "ha"      'apropos
      "hb"      'describe-bindings
      "hc"      'describe-char
      "hf"      'describe-function
      "hF"      'describe-face
      "hi"      'info-emacs-manual
      "hI"      'info-display-manual
      "hk"      'describe-key
      "hK"      'describe-keymap
      "hm"      'describe-mode
      "hM"      'woman
      "hp"      'describe-package
      "ht"      'describe-text-properties
      "hv"      'describe-variable
      "hP"      (cons "profiler" (make-sparse-keymap))
      "hPs"     'profiler-start
      "hPk"     'profiler-stop
      "hPr"     'profiler-report
  
      "j"       (cons "jump" (make-sparse-keymap))
      "ji"      'imenu
      "jg"      'avy-goto-char-2
  
      "l"       (cons "layouts" tab-prefix-map)
      "ld"      'tab-bar-close-tab
      "lD"      'tab-bar-close-other-tabs
      "lg"      'tab-bar-change-tab-group
      "lm"      'tab-bar-move-tab-to
      "lM"      'tab-bar-move-tab-to-group
      "ll"      'tab-bar-switch-to-tab
      "lR"      'tab-bar-rename-tab
      "lt"      'other-tab-prefix
      "lu"      'tab-bar-undo-close-tab
      "l TAB"   'tab-bar-switch-to-last-tab
  
      "m"       (cons "major mode" (make-sparse-keymap))
  
      "p"       (cons "projects" project-prefix-map)
      "pt"      'project-open-in-tab
  
      "q"       (cons "quit" (make-sparse-keymap))
      "qd"      'restart-emacs-debug-init
      "qr"      'restart-emacs
      "qR"      'restart-emacs-without-desktop
      "qf"      'delete-frame
      "qq"      'save-buffers-kill-terminal
      "qQ"      'save-buffers-kill-emacs
  
      "s"       (cons "search" (make-sparse-keymap))
      ;; "sb"      'flyspell-buffer
      ;; "sn"      'flyspell-goto-next-error
      ;; "sr"      'flyspell-region
  
      "T"       (cons "toggles" (make-sparse-keymap))
      "Ta"      'auto-fill-mode
      ;;"Td"      'toggle-debug-on-error
      "Tde"     'toggle-debug-on-error
      "Tdq"     'toggle-debug-on-quit
      "Tf"      'display-fill-column-indicator-mode
      "Tl"      'toggle-truncate-lines
      "Tm"      'flymake-mode
      "Tn"      'display-line-numbers-mode
      "Ts"      'flyspell-mode
      "Tw"      'whitespace-mode
      "TW"      'toggle-word-wrap
  
      "u"       '("universal arg" . universal-argument)
  
      "w"       (cons "windows" (make-sparse-keymap))
      "w TAB"   'alternate-window
      "w+"      'window-layout-toggle
      "w?" 'split-window-vertically
      "w=" 'balance-windows
      "w/" 'split-window-horizontally
      "wO" 'delete-other-windows
      "wX" '((lambda () (interactive) (call-interactively #'other-window) (kill-buffer-and-window)) :which-key "kill-other-buffer-and-window")
      "wd" 'delete-window
      "wh" 'windmove-left
      "wj" 'windmove-down
      "wk" 'windmove-up
      "wl" 'windmove-right
      "wo" 'other-window
      "wx" 'kill-buffer-and-window
  
      "wb"      'switch-to-minibuffer-window
      "wd"      'delete-window
      "wD"      'delete-other-windows
      "wm"      'toggle-maximize-buffer
      "wf"      'follow-mode
      "wh"      'evil-window-left
      "wH"      'evil-window-move-far-left
      "wj"      'evil-window-down
      "wJ"      'evil-window-move-very-bottom
      "wk"      'evil-window-up
      "wK"      'evil-window-move-very-top
      "wl"      'evil-window-right
      "wL"      'evil-window-move-far-right
      "wr"      'rotate-windows-forward
      "wR"      'rotate-windows-backward
      "ws"      'split-window-vertically
      "wS"      'split-window-vertically-and-focus
      "wt"      'toggle-current-window-dedication
      "wu"      'winner-undo
      "wU"      'winner-redo
      "wv"      'split-window-horizontally
      "wV"      'split-window-horizontally-and-focus))


#+END_SRC

** hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :demand t
  :config
  (defun hydra-move-split-left (arg)
    "Move window split left."
    (interactive "p")
    (if (let* ((windmove-wrap-around))
          (windmove-find-other-window 'right))
        (shrink-window-horizontally arg)
      (enlarge-window-horizontally arg)))
  
  (defun hydra-move-split-right (arg)
    "Move window split right."
    (interactive "p")
    (if (let* ((windmove-wrap-around))
          (windmove-find-other-window 'right))
        (enlarge-window-horizontally arg)
      (shrink-window-horizontally arg)))
  
  (defun hydra-move-split-up (arg)
    "Move window split up."
    (interactive "p")
    (if (let* ((windmove-wrap-around))
          (windmove-find-other-window 'up))
        (enlarge-window arg)
      (shrink-window arg)))
  
  (defun hydra-move-split-down (arg)
    "Move window split down."
    (interactive "p")
    (if (let* ((windmove-wrap-around))
          (windmove-find-other-window 'up))
        (shrink-window arg)
      (enlarge-window arg)))
  
  (defhydra emacy-hydra-window ()
    "
  Movement^^   ^Split^         ^Switch^     ^Resize^
  -----------------------------------------------------
  _h_ Left     _v_ertical                   _q_ X left
  _j_ Down     _x_ horizontal  _f_ind files _w_ X Down
  _k_ Top      _z_ undo        _a_ce 1      _e_ X Top
  _l_ Right    _Z_ reset       _s_wap       _r_ X Right
  _F_ollow     _D_elete Other  _S_ave       max_i_mize
  _SPC_ cancel _o_nly this     _d_elete
  "
    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)
    ("q" hydra-move-split-left)
    ("w" hydra-move-split-down)
    ("e" hydra-move-split-up)
    ("r" hydra-move-split-right)
    ("f" counsel-find-file)
    ("F" follow-mode)
    ("a" (ace-window 1))
    ("v" (lambda () (interactive) (split-window-right) (windmove-right)))
    ("x" (lambda () (interactive) (split-window-below) (windmove-down)))
    ("s" (ace-window 4))
    ("S" save-buffer)
    ("d" delete-window)
    ("D" (ace-window 16))
    ("o" delete-other-windows)
    ("i" ace-delete-other-windows)
    ("z" (progn (winner-undo) (setq this-command 'winner-undo)))
    ("Z" winner-redo)
    ("SPC" nil))
  
  ;;(emacy-definer "w ." 'emacy-hydra-window/body)
  
  (defhydra hydra-dired (:hint nil :color pink)
    "
  _+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
  _C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
  _D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
  _R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
  _Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
  _S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
  _r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
  _z_ compress-file  _A_ find regexp
  _Z_ compress       _Q_ repl regexp
  
  T - tag prefix
  "
    ("\\" dired-do-ispell)
    ("(" dired-hide-details-mode)
    (")" dired-omit-mode)
    ("+" dired-create-directory)
    ("=" diredp-ediff)         ;; smart diff
    ("?" dired-summary)
    ("$" diredp-hide-subdir-nomove)
    ("A" dired-do-find-regexp)
    ("C" dired-do-copy)        ;; Copy all marked files
    ("D" dired-do-delete)
    ("E" dired-mark-extension)
    ("e" dired-ediff-files)
    ("F" dired-do-find-marked-files)
    ("G" dired-do-chgrp)
    ("g" revert-buffer)        ;; read all directories again (refresh)
    ("i" dired-maybe-insert-subdir)
    ("l" dired-do-redisplay)   ;; relist the marked or singel directory
    ("M" dired-do-chmod)
    ("m" dired-mark)
    ("O" dired-display-file)
    ("o" dired-find-file-other-window)
    ("Q" dired-do-find-regexp-and-replace)
    ("R" dired-do-rename)
    ("r" dired-do-rsynch)
    ("S" dired-do-symlink)
    ("s" dired-sort-toggle-or-edit)
    ("t" dired-toggle-marks)
    ("U" dired-unmark-all-marks)
    ("u" dired-unmark)
    ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
    ("w" dired-kill-subdir)
    ("Y" dired-do-relsymlink)
    ("z" diredp-compress-this-file)
    ("Z" dired-do-compress)
    ("q" nil)
    ("." nil :color blue))
  
  ;; FIXME
  (general-define-key :keymaps 'dired-mode-map "." 'hydra-dired/body))
(use-package use-package-hydra :ensure t)

(elpaca-wait)
#+END_SRC

** TODO evil
#+BEGIN_SRC emacs-lisp
(use-package evil
  :demand t
  :preface (setq evil-want-keybinding nil)
  :custom
  (evil-want-integration t) ;; This is optional since it's already set to t by default.
  (evil-want-C-i-jump t)
  (evil-undo-system 'undo-fu)
  (evil-shift-width 2 "same behavior for vim")
  (evil-complete-all-buffers nil)
  :config
  (defun +evil-kill-minibuffer () (interactive)
    (when (windowp (active-minibuffer-window)) (evil-ex-search-exit)))

  (add-hook 'mouse-leave-buffer-hook #'+evil-kill-minibuffer)
  (evil-mode))

(use-package evil-collection
  :after (evil)
  :config (evil-collection-init)
  :custom
  (evil-collection-elpaca-want-g-filters nil)
  (evil-collection-setup-minibuffer t "Add evil bindings to minibuffer")
  (evil-collection-company-use-tng t))

(use-package evil-nerd-commenter
  :after (general)
  :commands (evilnc-comment-operator
             evilnc-inner-comment
             evilnc-outer-commenter)
  ;; :custom (general-define-key :state '(normal visual) "gc" 'evilnc-comment-operator)
  :general
  ([remap comment-line] #'evilnc-comment-or-uncomment-lines
   :keymaps 'prog-mode-map
   :states '(normal visual) "gc" 'evilnc-comment-operator))

(use-package evil-matchit :config (global-evil-matchit-mode 1))
(use-package evil-lion :elpaca (evil-lion :host github :repo "edkolev/evil-lion" :files ("*" (:exclude ".git"))) :config (evil-lion-mode))

(use-package evil-surround :config (global-evil-surround-mode 1))
(use-package evil-embrace
  :commands embrace-add-pair embrace-add-pair-regexp
  :after evil-surround
  :init (evil-embrace-enable-evil-surround-integration)
  :config (setq evil-embrace-show-help nil)
  :hook (org-mode . embrace-org-mode-hook)
  :hook (emace-lisp-mode . embrace-emacs-lisp-mode-hook))

(use-package evil-escape
  :commands evil-escape
  :init
  (setq evil-escape-excluded-states '(normal visual multiedit emacs motion)
        evil-escape-excluded-major-modes '(treemacs-mode vterm-mode))
  (evil-define-key '(insert replace visual operator) 'global "\C-g" #'evil-escape))

(use-package evil-exchange :config (evil-exchange-install))

(use-package evil-traces :after evil :config (evil-traces-use-diff-faces) (evil-traces-mode))

(use-package evil-goggles
  :after evil
  :demand
  :init
  (setq evil-goggles-duration 0.05)
  :config
  (push '(evil-operator-eval
          :face evil-goggles-yank-face
          :switch evil-goggles-enable-yank
          :advice evil-goggles--generic-async-advice)
        evil-goggles--commands)
  (evil-goggles-mode)
  (evil-goggles-use-diff-faces))

(use-package evil-snipe
  :after evil
  :demand
  :config
  (evil-snipe-mode +1)
  (evil-snipe-override-mode +1))

(use-package evil-iedit-state
  :elpaca (evil-iedit-state :repo "kassick/evil-iedit-state")
  :general
  (tyrant-def
    "s e" '(evil-iedit-state/iedit-mode :wk "iedit")
    "s q" '(evil-iedit-state/quit-iedit-mode :wk "quit iedit")))
#+END_SRC

* complete
** vertico
#+BEGIN_SRC emacs-lisp
(use-package vertico
  :demand
  ;; :general
  ;; (:keymaps 'vertico-map
  ;;           "C-j" #'vertico-next
  ;;           "C-k" #'vertico-previous)
  :config
  (vertico-mode))

;; Persist history over Emacs restarts. Vertico sorts by history position.
(savehist-mode)

;; A few more useful configurations...
(use-feature emacs
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" "" crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq display-line-numbers-type 'relative)
  (setq minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t))

;; support Pinyin first character match for orderless, avy etc.
(use-package pinyinlib :ensure t)

(use-package orderless
  :ensure t
  :init
  (setq completion-styles '(orderless partial-completion basic))
  (setq orderless-component-separator "[ &]") ; & is for company because space will break completion
  (setq completion-category-defaults nil)
  (setq completion-category-overrides nil)
  :config
  (defun completion--regex-pinyin (str) (orderless-regexp (pinyinlib-build-regexp-string str)))
  (add-to-list 'orderless-matching-styles 'completion--regex-pinyin))

;; minibuffer helpful annotations
(use-package marginalia
  :ensure t
  :hook (elpaca-after-init . marginalia-mode)
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))

(use-package consult
  :ensure t
  :after org
  :bind (([remap goto-line]                     . consult-goto-line)
         ([remap isearch-forward]               . consult-line-symbol-at-point) ; my-consult-ripgrep-or-line
         ([remap switch-to-buffer]              . consult-buffer)
         ([remap switch-to-buffer-other-window] . consult-buffer-other-window)
         ([remap switch-to-buffer-other-frame]  . consult-buffer-other-frame)
         ([remap yank-pop]                      . consult-yank-pop)
         ([remap apropos]                       . consult-apropos)
         ([remap bookmark-jump]                 . consult-bookmark)
         ([remap goto-line]                     . consult-goto-line)
         ([remap imenu]                         . consult-imenu)
         ([remap multi-occur]                   . consult-multi-occur)
         ([remap recentf-open-files]            . consult-recent-file)
         ("C-x j"                               . consult-mark)
         ("C-c g"                               . consult-ripgrep)
         ("C-c f"                               . consult-find)
         ("\e\ef"                               . consult-locate) ; need to enable locate first
         ("C-c n h"                             . my/consult-find-org-headings)
         :map org-mode-map
         ("C-c C-j"                             . consult-org-heading)
         :map minibuffer-local-map
         ("C-r"                                 . consult-history)
         :map isearch-mode-map
         ("C-;"                                 . consult-line)
         :map prog-mode-map
         ("C-c C-j"                             . consult-outline))
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :init
  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; MacOS locate doesn't support `--ignore-case --existing' args.
  (setq consult-locate-args (pcase system-type
                              ('gnu/linux "locate --ignore-case --existing --regex")
                              ('darwin "mdfind -name")))
  :config
  (consult-customize
    consult-theme
    :preview-key '(:debounce 0.2 any)
    consult-ripgrep consult-git-grep consult-grep
    consult-bookmark consult-recent-file consult-xref
    consult--source-recent-file consult--source-project-recent-file consult--source-bookmark
    :preview-key (kbd "M-."))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  (autoload 'projectile-project-root "projectile")
  (setq consult-project-root-function #'projectile-project-root)

  ;; Use `consult-ripgrep' instead of `consult-line' in large buffers
  (defun consult-line-symbol-at-point ()
    "Consult line the synbol where the point is"
    (interactive)
    (consult-line (thing-at-point 'symbol))))
#+END_SRC

** embark
#+BEGIN_SRC emacs-lisp
(use-package embark
  :demand t
  :ensure t
  :general
  (:keymaps 'override
   "C-;" 'embark-dwim
   :states '(normal insert motion emacs)
   "C-." 'embark-act)

  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
  ;; strategy, if you want to see the documentation from multiple providers.
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))


(use-package cape
  :ensure t
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-keyword)  ; programming language keyword
  (add-to-list 'completion-at-point-functions #'cape-ispell)
  (add-to-list 'completion-at-point-functions #'cape-dict)
  (add-to-list 'completion-at-point-functions #'cape-symbol)   ; elisp symbol
  (add-to-list 'completion-at-point-functions #'cape-line)

  :config
  (setq cape-dict-file (expand-file-name "etc/hunspell_dict.txt" user-emacs-directory))

  ;; for Eshell:
  ;; ===========
  ;; Silence the pcomplete capf, no errors or messages!
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

  ;; and behaves as a pure `completion-at-point-function'.
  ;; Ensure that pcomplete does not write to the buffer
  ;; and behaves as a pure `completion-at-point-function'.
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))
#+END_SRC

** corfu
#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :custom
    (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-auto t)                 ;; Enable auto completion
    (corfu-separator ?\s)          ;; Orderless field separator
    (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
    (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
    (corfu-preview-current nil)    ;; Disable current candidate preview
    (corfu-preselect 'prompt)      ;; Preselect the prompt
    (corfu-on-exact-match nil)     ;; Configure handling of exact matches
    (corfu-scroll-margin 5)        ;; Use scroll margin

    ;; Enable Corfu only for certain modes.
    ;; :hook ((prog-mode . corfu-mode)
    ;;        (shell-mode . corfu-mode)
    ;;        (eshell-mode . corfu-mode))

    ;; Recommended: Enable Corfu globally.  This is recommended since Dabbrev can
    ;; be used globally (M-/).  See also the customization variable
    ;; `global-corfu-modes' to exclude certain modes.
    :init
    (global-corfu-mode))
#+END_SRC

** vertico
#+BEGIN_SRC emacs-lisp
#+END_SRC

* UI
禁止展示菜单栏、工具栏和纵向滚动条
禁止菜单栏、工具栏、滚动条模式，禁止启动屏幕和文件对话框
禁止自动缩放窗口先
在这个阶段不编译
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)

(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)

(setq frame-inhibit-implied-resize t)
(setq inhibit-splash-screen t)
(setq use-file-dialog nil)

(setq comp-deferred-compilation nil)
#+END_SRC

** Theme

* Optimize
设置垃圾回收参数
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq gc-cons-threshold most-positive-fixnum)
(setq gc-cons-percentage 0.6)
#+END_SRC

* IDE

* Other
** TODO Develop
:PROPERTIES:
:HEADER-ARGS: :tangle init-dev.el
:END:
Evaluated when loading init file.
Cleaner to keep this in a separate file rather than a long single line at the top of init.org
#+BEGIN_SRC emacs-lisp
  ;;; init-dev.el --- development settings for init file  -*- lexical-binding: t; -*-
  (defcustom emacy-library-directory (concat user-emacs-directory "libs/"))

  (add-to-list 'load-path (concat emacy-library-directory "org-auto-tangle"))

  (setq-local org-confirm-babel-evaluate nil)
  (require 'org-auto-tangle)
  (org-auto-tangle-mode)
  (add-hook 'org-auto-tangle-before-tangle-hook #'check-parens)
  (add-hook 'org-auto-tangle-after-tangle-hook
            (lambda () (load-file (concat user-emacs-directory "init.el"))
              (when-let ((forms (elpaca-q<-forms (car elpaca--queues))))
                (eval `(progn ,@(apply #'append (mapcar #'cdr (reverse forms)))) t))))
  (eldoc-mode)
  (provide 'init-dev)
  ;;; init-dev.el ends here
#+END_SRC

* Footer
#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (provide 'early-init)
  ;;; early-init.el ends here
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+END_SRC

* Reference
https://remacs.cc/
